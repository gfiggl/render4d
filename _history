{"entries":[{"timestamp":1771536563220,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":115,"length1":0,"diffs":[[1,"        \"main.blocks\",\n"]]},{"start1":178,"length1":45,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":207,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"removed","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"},{"type":"added","filename":"render3d.ts","value":"namespace render {\n    \n}\n\nnamespace vector {\n    \n}"}]},{"timestamp":1771576251285,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"render3d.ts","patch":[{"start1":19,"length1":12,"diffs":[[1,"    \n"]]}]}]},{"timestamp":1771611135820,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"render3d.ts","patch":[{"start1":19,"length1":5,"diffs":[[1,"    export \n"]]},{"start1":34,"length1":68,"diffs":[[1,"namespace vector {\n    \n"]]}]}]},{"timestamp":1771619932148,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"render3d.ts","patch":[{"start1":0,"length1":2,"diffs":[[1,""]]},{"start1":27,"length1":214,"diffs":[[1,"function mul(out:uint32[],vec:uint32[]) {\n    out[]\n    return out;\n"]]}]}]},{"timestamp":1771668666095,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"render3d.ts","patch":[{"start1":21,"length1":98,"diffs":[[1,"    \n"]]},{"start1":182,"length1":60,"diffs":[[1,"    return vec1[0]*vecx2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n"]]}]}]},{"timestamp":1771767645261,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"render3d.ts","patch":[{"start1":48,"length1":70,"diffs":[[1,"        (data: uint32[], norm:uint32[], uniforms:uint32[][]):any\n"]]}]}]},{"timestamp":1771783563207,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":39,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":178,"length1":20,"diffs":[[1,"        \"render3d.ts\"\n"]]}]},{"type":"removed","filename":"render3d.ts","value":"\n\nnamespace render {\n    interface VertShader {\n        (data: uint32[], norm:uint32[], uniforms:uint32[][]):uint32[]\n    }\n}\n\nfunction dot(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}\n\nfunction cross(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}"},{"type":"added","filename":"render.ts","value":"namespace render {\n    /**vertex shader\n     *                                                             \n     * takes some data and norms, applies them to some uniforms and outputs the new data\n     * \n     * (data,norm,uniforms)->new_data (could include new norms)\n     */\n    export interface VertShader {\n        (data: uint32[], norm: uint32[], uniforms: uint32[][]): uint32[]\n    }\n\n    /**fragment shader\n     * \n     * takes in data and outputs a color\n     * \n     * data->color\n     */\n    export interface FragShader {\n        (data: uint32[]): uint8\n    }\n\n    /**dot product - x1 \\* x2 + y1 \\* y2 + z1 \\* z2*/\n    export function dot(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n    }\n\n    /**cross product - x1 \\* y2 - y1 \\* x2*/\n    export function cross(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    }\n}"}]},{"timestamp":1771797953206,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":66,"diffs":[[1,"const vertex:render.VertShader = ()->{}"]]}]}]},{"timestamp":1771830555531,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":60,"length1":16,"diffs":[[1,"    \n"]]}]}]},{"timestamp":1771879664972,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":60,"length1":17,"diffs":[[1,"    return data\n"]]}]}]},{"timestamp":1771921314327,"editorVersion":"4.0.7","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":205,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1771536563219,"editorVersion":"4.0.5","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1771619091370,"editorVersion":"4.0.7","text":{"main.ts":"\n","README.md":" ","assets.json":"","render3d.ts":"namespace render {\n    export function \n}\n\nexport function mul(*)","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render3d.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1771697907876,"editorVersion":"4.0.7","text":{"main.ts":"\n","README.md":" ","assets.json":"","render3d.ts":"\n\nnamespace render {\n    \n}\n\nfunction dot(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}\n\nfunction cross(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render3d.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1771796245236,"editorVersion":"4.0.7","text":{"main.ts":"\n","README.md":" ","assets.json":"","render3d.ts":"\n\nnamespace render {\n    /**vertex shader\n     *                                                             \n     * takes some data and norms, applies them to some uniforms and outputs the new data\n     * \n     * (data,norm,uniforms)->new_data (could include new norms)\n     */\n    interface VertShader {\n        (data: uint32[], norm:uint32[], uniforms:uint32[][]):uint32[]\n    }\n\n    /**fragment shader\n     * \n     * takes in data and outputs a color\n     * \n     * data->color\n     */\n    interface FragShader {\n        (data: uint32[]):uint8\n    }\n\n    \n}\n\n/**dot product - x**x+y**y*/\nfunction dot(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}\n\nfunction cross(vec1:uint32[],vec2:uint32[]) {\n    return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];\n}","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render3d.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1771829970507,"editorVersion":"4.0.7","text":{"main.ts":"const vertex:render.VertShader = ()->{}","README.md":" ","assets.json":"","render.ts":"namespace render {\n    /**vertex shader\n     *                                                             \n     * takes some data and norms, applies them to some uniforms and outputs the new data\n     * \n     * (data,norm,uniforms)->new_data (could include new norms)\n     */\n    export interface VertShader {\n        (data: uint32[], norm: uint32[], uniforms: uint32[][]): uint32[]\n    }\n\n    /**fragment shader\n     * \n     * takes in data and outputs a color\n     * \n     * data->color\n     */\n    export interface FragShader {\n        (data: uint32[]): uint8\n    }\n\n    /**dot product - x1 \\* x2 + y1 \\* y2 + z1 \\* z2*/\n    export function dot(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n    }\n\n    /**cross product - x1 \\* y2 - y1 \\* x2*/\n    export function cross(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    }\n}","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1771879664972,"editorVersion":"4.0.7","text":{"main.ts":"const vertex:render.VertShader = (data,norms,uniforms) => {\n    \n}","README.md":" ","assets.json":"","render.ts":"namespace render {\n    /**vertex shader\n     *                                                             \n     * takes some data and norms, applies them to some uniforms and outputs the new data\n     * \n     * (data,norm,uniforms)->new_data (could include new norms)\n     */\n    export interface VertShader {\n        (data: uint32[], norm: uint32[], uniforms: uint32[][]): uint32[]\n    }\n\n    /**fragment shader\n     * \n     * takes in data and outputs a color\n     * \n     * data->color\n     */\n    export interface FragShader {\n        (data: uint32[]): uint8\n    }\n\n    /**dot product - x1 \\* x2 + y1 \\* y2 + z1 \\* z2*/\n    export function dot(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n    }\n\n    /**cross product - x1 \\* y2 - y1 \\* x2*/\n    export function cross(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    }\n}","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1771921022415,"editorVersion":"4.0.7","text":{"main.ts":"const vertex:render.VertShader = (data,norms,uniforms) => {\n    return data;\n}","README.md":" ","assets.json":"","render.ts":"namespace render {\n    /**vertex shader\n     *                                                             \n     * takes some data and norms, applies them to some uniforms and outputs the new data\n     * \n     * (data,norm,uniforms)->new_data (could include new norms)\n     */\n    export interface VertShader {\n        (data: uint32[], norm: uint32[], uniforms: uint32[][]): uint32[]\n    }\n\n    /**fragment shader\n     * \n     * takes in data and outputs a color\n     * \n     * data->color\n     */\n    export interface FragShader {\n        (data: uint32[]): uint8\n    }\n\n    /**dot product - x1 \\* x2 + y1 \\* y2 + z1 \\* z2*/\n    export function dot(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];\n    }\n\n    /**cross product - x1 \\* y2 - y1 \\* x2*/\n    export function cross(vec1: uint32[], vec2: uint32[]) {\n        return vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    }\n}","pxt.json":"{\n    \"name\": \"render3d\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"render.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1771921314349}